// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: server/v1/server.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Address_CreateAddress_FullMethodName            = "/api.server.v1.Address/CreateAddress"
	Address_CreateAddressBatch_FullMethodName       = "/api.server.v1.Address/CreateAddressBatch"
	Address_StoreSecret_FullMethodName              = "/api.server.v1.Address/StoreSecret"
	Address_DecodeSecret_FullMethodName             = "/api.server.v1.Address/DecodeSecret"
	Address_StoreSecretBatch_FullMethodName         = "/api.server.v1.Address/StoreSecretBatch"
	Address_DecodeSecretBatch_FullMethodName        = "/api.server.v1.Address/DecodeSecretBatch"
	Address_SignTx_FullMethodName                   = "/api.server.v1.Address/SignTx"
	Address_SignTxBatch_FullMethodName              = "/api.server.v1.Address/SignTxBatch"
	Address_Withdrawal_FullMethodName               = "/api.server.v1.Address/Withdrawal"
	Address_GetOrderDetail_FullMethodName           = "/api.server.v1.Address/GetOrderDetail"
	Address_CreateMultiSignTransfer_FullMethodName  = "/api.server.v1.Address/CreateMultiSignTransfer"
	Address_CreateMultiSignWallet_FullMethodName    = "/api.server.v1.Address/CreateMultiSignWallet"
	Address_GetMultiSignWalletTxList_FullMethodName = "/api.server.v1.Address/GetMultiSignWalletTxList"
)

// AddressClient is the client API for Address service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AddressClient interface {
	CreateAddress(ctx context.Context, in *CreateAddressRequest, opts ...grpc.CallOption) (*CreateAddressReply, error)
	CreateAddressBatch(ctx context.Context, in *CreateAddressBatchRequest, opts ...grpc.CallOption) (*CreateAddressBatchReply, error)
	StoreSecret(ctx context.Context, in *StoreSecretRequest, opts ...grpc.CallOption) (*StoreSecretReply, error)
	DecodeSecret(ctx context.Context, in *DecodeSecretRequest, opts ...grpc.CallOption) (*DecodeSecretReply, error)
	StoreSecretBatch(ctx context.Context, in *StoreSecretBatchRequest, opts ...grpc.CallOption) (*StoreSecretBatchReply, error)
	DecodeSecretBatch(ctx context.Context, in *DecodeSecretBatchRequest, opts ...grpc.CallOption) (*DecodeSecretBatchReply, error)
	SignTx(ctx context.Context, in *SignTxRequest, opts ...grpc.CallOption) (*SignTxReply, error)
	SignTxBatch(ctx context.Context, in *SignTxBatchRequest, opts ...grpc.CallOption) (*SignTxBatchReply, error)
	Withdrawal(ctx context.Context, in *WithdrawalRequest, opts ...grpc.CallOption) (*WithdrawalReply, error)
	GetOrderDetail(ctx context.Context, in *GetOrderDetailRequest, opts ...grpc.CallOption) (*GetOrderDetailReply, error)
	// 创建多签转账交易，返回用户签名页面地址
	CreateMultiSignTransfer(ctx context.Context, in *CreateMultiSignTransferRequest, opts ...grpc.CallOption) (*CreateMultiSignTransferReply, error)
	// 创建多签钱包，TRON为升级多签钱包，EVM为创建，返回多签地址
	CreateMultiSignWallet(ctx context.Context, in *CreateMultiSignWalletRequest, opts ...grpc.CallOption) (*CreateMultiSignWalletReply, error)
	// 获取当前多签钱包交易列表
	GetMultiSignWalletTxList(ctx context.Context, in *GetMultiSignWalletTxListRequest, opts ...grpc.CallOption) (*GetMultiSignWalletTxListReply, error)
}

type addressClient struct {
	cc grpc.ClientConnInterface
}

func NewAddressClient(cc grpc.ClientConnInterface) AddressClient {
	return &addressClient{cc}
}

func (c *addressClient) CreateAddress(ctx context.Context, in *CreateAddressRequest, opts ...grpc.CallOption) (*CreateAddressReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAddressReply)
	err := c.cc.Invoke(ctx, Address_CreateAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) CreateAddressBatch(ctx context.Context, in *CreateAddressBatchRequest, opts ...grpc.CallOption) (*CreateAddressBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAddressBatchReply)
	err := c.cc.Invoke(ctx, Address_CreateAddressBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) StoreSecret(ctx context.Context, in *StoreSecretRequest, opts ...grpc.CallOption) (*StoreSecretReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreSecretReply)
	err := c.cc.Invoke(ctx, Address_StoreSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) DecodeSecret(ctx context.Context, in *DecodeSecretRequest, opts ...grpc.CallOption) (*DecodeSecretReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeSecretReply)
	err := c.cc.Invoke(ctx, Address_DecodeSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) StoreSecretBatch(ctx context.Context, in *StoreSecretBatchRequest, opts ...grpc.CallOption) (*StoreSecretBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreSecretBatchReply)
	err := c.cc.Invoke(ctx, Address_StoreSecretBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) DecodeSecretBatch(ctx context.Context, in *DecodeSecretBatchRequest, opts ...grpc.CallOption) (*DecodeSecretBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeSecretBatchReply)
	err := c.cc.Invoke(ctx, Address_DecodeSecretBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) SignTx(ctx context.Context, in *SignTxRequest, opts ...grpc.CallOption) (*SignTxReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignTxReply)
	err := c.cc.Invoke(ctx, Address_SignTx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) SignTxBatch(ctx context.Context, in *SignTxBatchRequest, opts ...grpc.CallOption) (*SignTxBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignTxBatchReply)
	err := c.cc.Invoke(ctx, Address_SignTxBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) Withdrawal(ctx context.Context, in *WithdrawalRequest, opts ...grpc.CallOption) (*WithdrawalReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WithdrawalReply)
	err := c.cc.Invoke(ctx, Address_Withdrawal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) GetOrderDetail(ctx context.Context, in *GetOrderDetailRequest, opts ...grpc.CallOption) (*GetOrderDetailReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOrderDetailReply)
	err := c.cc.Invoke(ctx, Address_GetOrderDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) CreateMultiSignTransfer(ctx context.Context, in *CreateMultiSignTransferRequest, opts ...grpc.CallOption) (*CreateMultiSignTransferReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMultiSignTransferReply)
	err := c.cc.Invoke(ctx, Address_CreateMultiSignTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) CreateMultiSignWallet(ctx context.Context, in *CreateMultiSignWalletRequest, opts ...grpc.CallOption) (*CreateMultiSignWalletReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMultiSignWalletReply)
	err := c.cc.Invoke(ctx, Address_CreateMultiSignWallet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressClient) GetMultiSignWalletTxList(ctx context.Context, in *GetMultiSignWalletTxListRequest, opts ...grpc.CallOption) (*GetMultiSignWalletTxListReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMultiSignWalletTxListReply)
	err := c.cc.Invoke(ctx, Address_GetMultiSignWalletTxList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AddressServer is the server API for Address service.
// All implementations must embed UnimplementedAddressServer
// for forward compatibility.
type AddressServer interface {
	CreateAddress(context.Context, *CreateAddressRequest) (*CreateAddressReply, error)
	CreateAddressBatch(context.Context, *CreateAddressBatchRequest) (*CreateAddressBatchReply, error)
	StoreSecret(context.Context, *StoreSecretRequest) (*StoreSecretReply, error)
	DecodeSecret(context.Context, *DecodeSecretRequest) (*DecodeSecretReply, error)
	StoreSecretBatch(context.Context, *StoreSecretBatchRequest) (*StoreSecretBatchReply, error)
	DecodeSecretBatch(context.Context, *DecodeSecretBatchRequest) (*DecodeSecretBatchReply, error)
	SignTx(context.Context, *SignTxRequest) (*SignTxReply, error)
	SignTxBatch(context.Context, *SignTxBatchRequest) (*SignTxBatchReply, error)
	Withdrawal(context.Context, *WithdrawalRequest) (*WithdrawalReply, error)
	GetOrderDetail(context.Context, *GetOrderDetailRequest) (*GetOrderDetailReply, error)
	// 创建多签转账交易，返回用户签名页面地址
	CreateMultiSignTransfer(context.Context, *CreateMultiSignTransferRequest) (*CreateMultiSignTransferReply, error)
	// 创建多签钱包，TRON为升级多签钱包，EVM为创建，返回多签地址
	CreateMultiSignWallet(context.Context, *CreateMultiSignWalletRequest) (*CreateMultiSignWalletReply, error)
	// 获取当前多签钱包交易列表
	GetMultiSignWalletTxList(context.Context, *GetMultiSignWalletTxListRequest) (*GetMultiSignWalletTxListReply, error)
	mustEmbedUnimplementedAddressServer()
}

// UnimplementedAddressServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAddressServer struct{}

func (UnimplementedAddressServer) CreateAddress(context.Context, *CreateAddressRequest) (*CreateAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAddress not implemented")
}
func (UnimplementedAddressServer) CreateAddressBatch(context.Context, *CreateAddressBatchRequest) (*CreateAddressBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAddressBatch not implemented")
}
func (UnimplementedAddressServer) StoreSecret(context.Context, *StoreSecretRequest) (*StoreSecretReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreSecret not implemented")
}
func (UnimplementedAddressServer) DecodeSecret(context.Context, *DecodeSecretRequest) (*DecodeSecretReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeSecret not implemented")
}
func (UnimplementedAddressServer) StoreSecretBatch(context.Context, *StoreSecretBatchRequest) (*StoreSecretBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreSecretBatch not implemented")
}
func (UnimplementedAddressServer) DecodeSecretBatch(context.Context, *DecodeSecretBatchRequest) (*DecodeSecretBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeSecretBatch not implemented")
}
func (UnimplementedAddressServer) SignTx(context.Context, *SignTxRequest) (*SignTxReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignTx not implemented")
}
func (UnimplementedAddressServer) SignTxBatch(context.Context, *SignTxBatchRequest) (*SignTxBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignTxBatch not implemented")
}
func (UnimplementedAddressServer) Withdrawal(context.Context, *WithdrawalRequest) (*WithdrawalReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdrawal not implemented")
}
func (UnimplementedAddressServer) GetOrderDetail(context.Context, *GetOrderDetailRequest) (*GetOrderDetailReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrderDetail not implemented")
}
func (UnimplementedAddressServer) CreateMultiSignTransfer(context.Context, *CreateMultiSignTransferRequest) (*CreateMultiSignTransferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMultiSignTransfer not implemented")
}
func (UnimplementedAddressServer) CreateMultiSignWallet(context.Context, *CreateMultiSignWalletRequest) (*CreateMultiSignWalletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMultiSignWallet not implemented")
}
func (UnimplementedAddressServer) GetMultiSignWalletTxList(context.Context, *GetMultiSignWalletTxListRequest) (*GetMultiSignWalletTxListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMultiSignWalletTxList not implemented")
}
func (UnimplementedAddressServer) mustEmbedUnimplementedAddressServer() {}
func (UnimplementedAddressServer) testEmbeddedByValue()                 {}

// UnsafeAddressServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AddressServer will
// result in compilation errors.
type UnsafeAddressServer interface {
	mustEmbedUnimplementedAddressServer()
}

func RegisterAddressServer(s grpc.ServiceRegistrar, srv AddressServer) {
	// If the following call pancis, it indicates UnimplementedAddressServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Address_ServiceDesc, srv)
}

func _Address_CreateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).CreateAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_CreateAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).CreateAddress(ctx, req.(*CreateAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_CreateAddressBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAddressBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).CreateAddressBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_CreateAddressBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).CreateAddressBatch(ctx, req.(*CreateAddressBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_StoreSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).StoreSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_StoreSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).StoreSecret(ctx, req.(*StoreSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_DecodeSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).DecodeSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_DecodeSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).DecodeSecret(ctx, req.(*DecodeSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_StoreSecretBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreSecretBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).StoreSecretBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_StoreSecretBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).StoreSecretBatch(ctx, req.(*StoreSecretBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_DecodeSecretBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeSecretBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).DecodeSecretBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_DecodeSecretBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).DecodeSecretBatch(ctx, req.(*DecodeSecretBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_SignTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).SignTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_SignTx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).SignTx(ctx, req.(*SignTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_SignTxBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignTxBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).SignTxBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_SignTxBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).SignTxBatch(ctx, req.(*SignTxBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_Withdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).Withdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_Withdrawal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).Withdrawal(ctx, req.(*WithdrawalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_GetOrderDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrderDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).GetOrderDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_GetOrderDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).GetOrderDetail(ctx, req.(*GetOrderDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_CreateMultiSignTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMultiSignTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).CreateMultiSignTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_CreateMultiSignTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).CreateMultiSignTransfer(ctx, req.(*CreateMultiSignTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_CreateMultiSignWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMultiSignWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).CreateMultiSignWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_CreateMultiSignWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).CreateMultiSignWallet(ctx, req.(*CreateMultiSignWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Address_GetMultiSignWalletTxList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMultiSignWalletTxListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServer).GetMultiSignWalletTxList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Address_GetMultiSignWalletTxList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServer).GetMultiSignWalletTxList(ctx, req.(*GetMultiSignWalletTxListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Address_ServiceDesc is the grpc.ServiceDesc for Address service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Address_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.server.v1.Address",
	HandlerType: (*AddressServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAddress",
			Handler:    _Address_CreateAddress_Handler,
		},
		{
			MethodName: "CreateAddressBatch",
			Handler:    _Address_CreateAddressBatch_Handler,
		},
		{
			MethodName: "StoreSecret",
			Handler:    _Address_StoreSecret_Handler,
		},
		{
			MethodName: "DecodeSecret",
			Handler:    _Address_DecodeSecret_Handler,
		},
		{
			MethodName: "StoreSecretBatch",
			Handler:    _Address_StoreSecretBatch_Handler,
		},
		{
			MethodName: "DecodeSecretBatch",
			Handler:    _Address_DecodeSecretBatch_Handler,
		},
		{
			MethodName: "SignTx",
			Handler:    _Address_SignTx_Handler,
		},
		{
			MethodName: "SignTxBatch",
			Handler:    _Address_SignTxBatch_Handler,
		},
		{
			MethodName: "Withdrawal",
			Handler:    _Address_Withdrawal_Handler,
		},
		{
			MethodName: "GetOrderDetail",
			Handler:    _Address_GetOrderDetail_Handler,
		},
		{
			MethodName: "CreateMultiSignTransfer",
			Handler:    _Address_CreateMultiSignTransfer_Handler,
		},
		{
			MethodName: "CreateMultiSignWallet",
			Handler:    _Address_CreateMultiSignWallet_Handler,
		},
		{
			MethodName: "GetMultiSignWalletTxList",
			Handler:    _Address_GetMultiSignWalletTxList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "server/v1/server.proto",
}
