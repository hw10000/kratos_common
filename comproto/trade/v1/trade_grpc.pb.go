// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: trade/v1/trade.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Trade_GetTokenInfo_FullMethodName            = "/api.trade.v1.Trade/GetTokenInfo"
	Trade_GetTokenPrice_FullMethodName           = "/api.trade.v1.Trade/GetTokenPrice"
	Trade_GetTokenMarketCap_FullMethodName       = "/api.trade.v1.Trade/GetTokenMarketCap"
	Trade_GetTokenLiquidity_FullMethodName       = "/api.trade.v1.Trade/GetTokenLiquidity"
	Trade_GetTokenTradeInfo_FullMethodName       = "/api.trade.v1.Trade/GetTokenTradeInfo"
	Trade_TradeTokenRawTx_FullMethodName         = "/api.trade.v1.Trade/TradeTokenRawTx"
	Trade_GetNativeBalance_FullMethodName        = "/api.trade.v1.Trade/GetNativeBalance"
	Trade_GetContractTokenBalance_FullMethodName = "/api.trade.v1.Trade/GetContractTokenBalance"
	Trade_GetAddressNetworkType_FullMethodName   = "/api.trade.v1.Trade/GetAddressNetworkType"
	Trade_IsContract_FullMethodName              = "/api.trade.v1.Trade/IsContract"
	Trade_BuildTokenTransfer_FullMethodName      = "/api.trade.v1.Trade/BuildTokenTransfer"
	Trade_SecurityCheck_FullMethodName           = "/api.trade.v1.Trade/SecurityCheck"
	Trade_GetNativeTokenPrice_FullMethodName     = "/api.trade.v1.Trade/GetNativeTokenPrice"
	Trade_SendRawTx_FullMethodName               = "/api.trade.v1.Trade/SendRawTx"
	Trade_SendRawTxByPrivate_FullMethodName      = "/api.trade.v1.Trade/SendRawTxByPrivate"
	Trade_GetTransactionStatus_FullMethodName    = "/api.trade.v1.Trade/GetTransactionStatus"
	Trade_CreateAddress_FullMethodName           = "/api.trade.v1.Trade/CreateAddress"
	Trade_StoreSecret_FullMethodName             = "/api.trade.v1.Trade/StoreSecret"
	Trade_DecodeSecret_FullMethodName            = "/api.trade.v1.Trade/DecodeSecret"
	Trade_StoreSecretBatch_FullMethodName        = "/api.trade.v1.Trade/StoreSecretBatch"
	Trade_DecodeSecretBatch_FullMethodName       = "/api.trade.v1.Trade/DecodeSecretBatch"
	Trade_SignTx_FullMethodName                  = "/api.trade.v1.Trade/SignTx"
	Trade_SignTxBatch_FullMethodName             = "/api.trade.v1.Trade/SignTxBatch"
)

// TradeClient is the client API for Trade service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TradeClient interface {
	GetTokenInfo(ctx context.Context, in *GetTokenInfoRequest, opts ...grpc.CallOption) (*GetTokenInfoReply, error)
	GetTokenPrice(ctx context.Context, in *GetTokenPriceRequest, opts ...grpc.CallOption) (*GetTokenPriceReply, error)
	GetTokenMarketCap(ctx context.Context, in *GetTokenMarketCapRequest, opts ...grpc.CallOption) (*GetTokenMarketCapReply, error)
	GetTokenLiquidity(ctx context.Context, in *GetTokenLiquidityRequest, opts ...grpc.CallOption) (*GetTokenLiquidityReply, error)
	GetTokenTradeInfo(ctx context.Context, in *GetTokenTradeInfoRequest, opts ...grpc.CallOption) (*GetTokenTradeInfoReply, error)
	TradeTokenRawTx(ctx context.Context, in *TradeTokenRawTxRequest, opts ...grpc.CallOption) (*TradeTokenRawTxReply, error)
	GetNativeBalance(ctx context.Context, in *GetNativeBalanceRequest, opts ...grpc.CallOption) (*GetNativeBalanceReply, error)
	GetContractTokenBalance(ctx context.Context, in *GetContractTokenBalanceRequest, opts ...grpc.CallOption) (*GetContractTokenBalanceReply, error)
	GetAddressNetworkType(ctx context.Context, in *GetAddressNetworkTypeRequest, opts ...grpc.CallOption) (*GetAddressNetworkTypeReply, error)
	IsContract(ctx context.Context, in *IsContractRequest, opts ...grpc.CallOption) (*IsContractReply, error)
	// 构建代币转账交易 代币地址为空时走主网币
	BuildTokenTransfer(ctx context.Context, in *BuildTokenTransferRequest, opts ...grpc.CallOption) (*BuildTokenTransferReply, error)
	SecurityCheck(ctx context.Context, in *SecurityCheckRequest, opts ...grpc.CallOption) (*SecurityCheckReply, error)
	GetNativeTokenPrice(ctx context.Context, in *GetNativeTokenPriceRequest, opts ...grpc.CallOption) (*GetNativeTokenPriceReply, error)
	SendRawTx(ctx context.Context, in *SendRawTxRequest, opts ...grpc.CallOption) (*SendRawTxReply, error)
	SendRawTxByPrivate(ctx context.Context, in *SendRawTxByPrivateRequest, opts ...grpc.CallOption) (*SendRawTxByPrivateReply, error)
	// 交易状态
	GetTransactionStatus(ctx context.Context, in *GetTransactionStatusRequest, opts ...grpc.CallOption) (*GetTransactionStatusReply, error)
	CreateAddress(ctx context.Context, in *CreateAddressRequest, opts ...grpc.CallOption) (*CreateAddressReply, error)
	StoreSecret(ctx context.Context, in *StoreSecretRequest, opts ...grpc.CallOption) (*StoreSecretReply, error)
	DecodeSecret(ctx context.Context, in *DecodeSecretRequest, opts ...grpc.CallOption) (*DecodeSecretReply, error)
	StoreSecretBatch(ctx context.Context, in *StoreSecretBatchRequest, opts ...grpc.CallOption) (*StoreSecretBatchReply, error)
	DecodeSecretBatch(ctx context.Context, in *DecodeSecretBatchRequest, opts ...grpc.CallOption) (*DecodeSecretBatchReply, error)
	SignTx(ctx context.Context, in *SignTxRequest, opts ...grpc.CallOption) (*SignTxReply, error)
	SignTxBatch(ctx context.Context, in *SignTxBatchRequest, opts ...grpc.CallOption) (*SignTxBatchReply, error)
}

type tradeClient struct {
	cc grpc.ClientConnInterface
}

func NewTradeClient(cc grpc.ClientConnInterface) TradeClient {
	return &tradeClient{cc}
}

func (c *tradeClient) GetTokenInfo(ctx context.Context, in *GetTokenInfoRequest, opts ...grpc.CallOption) (*GetTokenInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenInfoReply)
	err := c.cc.Invoke(ctx, Trade_GetTokenInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) GetTokenPrice(ctx context.Context, in *GetTokenPriceRequest, opts ...grpc.CallOption) (*GetTokenPriceReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenPriceReply)
	err := c.cc.Invoke(ctx, Trade_GetTokenPrice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) GetTokenMarketCap(ctx context.Context, in *GetTokenMarketCapRequest, opts ...grpc.CallOption) (*GetTokenMarketCapReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenMarketCapReply)
	err := c.cc.Invoke(ctx, Trade_GetTokenMarketCap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) GetTokenLiquidity(ctx context.Context, in *GetTokenLiquidityRequest, opts ...grpc.CallOption) (*GetTokenLiquidityReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenLiquidityReply)
	err := c.cc.Invoke(ctx, Trade_GetTokenLiquidity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) GetTokenTradeInfo(ctx context.Context, in *GetTokenTradeInfoRequest, opts ...grpc.CallOption) (*GetTokenTradeInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenTradeInfoReply)
	err := c.cc.Invoke(ctx, Trade_GetTokenTradeInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) TradeTokenRawTx(ctx context.Context, in *TradeTokenRawTxRequest, opts ...grpc.CallOption) (*TradeTokenRawTxReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TradeTokenRawTxReply)
	err := c.cc.Invoke(ctx, Trade_TradeTokenRawTx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) GetNativeBalance(ctx context.Context, in *GetNativeBalanceRequest, opts ...grpc.CallOption) (*GetNativeBalanceReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNativeBalanceReply)
	err := c.cc.Invoke(ctx, Trade_GetNativeBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) GetContractTokenBalance(ctx context.Context, in *GetContractTokenBalanceRequest, opts ...grpc.CallOption) (*GetContractTokenBalanceReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetContractTokenBalanceReply)
	err := c.cc.Invoke(ctx, Trade_GetContractTokenBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) GetAddressNetworkType(ctx context.Context, in *GetAddressNetworkTypeRequest, opts ...grpc.CallOption) (*GetAddressNetworkTypeReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAddressNetworkTypeReply)
	err := c.cc.Invoke(ctx, Trade_GetAddressNetworkType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) IsContract(ctx context.Context, in *IsContractRequest, opts ...grpc.CallOption) (*IsContractReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsContractReply)
	err := c.cc.Invoke(ctx, Trade_IsContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) BuildTokenTransfer(ctx context.Context, in *BuildTokenTransferRequest, opts ...grpc.CallOption) (*BuildTokenTransferReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildTokenTransferReply)
	err := c.cc.Invoke(ctx, Trade_BuildTokenTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) SecurityCheck(ctx context.Context, in *SecurityCheckRequest, opts ...grpc.CallOption) (*SecurityCheckReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SecurityCheckReply)
	err := c.cc.Invoke(ctx, Trade_SecurityCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) GetNativeTokenPrice(ctx context.Context, in *GetNativeTokenPriceRequest, opts ...grpc.CallOption) (*GetNativeTokenPriceReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNativeTokenPriceReply)
	err := c.cc.Invoke(ctx, Trade_GetNativeTokenPrice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) SendRawTx(ctx context.Context, in *SendRawTxRequest, opts ...grpc.CallOption) (*SendRawTxReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendRawTxReply)
	err := c.cc.Invoke(ctx, Trade_SendRawTx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) SendRawTxByPrivate(ctx context.Context, in *SendRawTxByPrivateRequest, opts ...grpc.CallOption) (*SendRawTxByPrivateReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendRawTxByPrivateReply)
	err := c.cc.Invoke(ctx, Trade_SendRawTxByPrivate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) GetTransactionStatus(ctx context.Context, in *GetTransactionStatusRequest, opts ...grpc.CallOption) (*GetTransactionStatusReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTransactionStatusReply)
	err := c.cc.Invoke(ctx, Trade_GetTransactionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) CreateAddress(ctx context.Context, in *CreateAddressRequest, opts ...grpc.CallOption) (*CreateAddressReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAddressReply)
	err := c.cc.Invoke(ctx, Trade_CreateAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) StoreSecret(ctx context.Context, in *StoreSecretRequest, opts ...grpc.CallOption) (*StoreSecretReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreSecretReply)
	err := c.cc.Invoke(ctx, Trade_StoreSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) DecodeSecret(ctx context.Context, in *DecodeSecretRequest, opts ...grpc.CallOption) (*DecodeSecretReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeSecretReply)
	err := c.cc.Invoke(ctx, Trade_DecodeSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) StoreSecretBatch(ctx context.Context, in *StoreSecretBatchRequest, opts ...grpc.CallOption) (*StoreSecretBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreSecretBatchReply)
	err := c.cc.Invoke(ctx, Trade_StoreSecretBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) DecodeSecretBatch(ctx context.Context, in *DecodeSecretBatchRequest, opts ...grpc.CallOption) (*DecodeSecretBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeSecretBatchReply)
	err := c.cc.Invoke(ctx, Trade_DecodeSecretBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) SignTx(ctx context.Context, in *SignTxRequest, opts ...grpc.CallOption) (*SignTxReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignTxReply)
	err := c.cc.Invoke(ctx, Trade_SignTx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) SignTxBatch(ctx context.Context, in *SignTxBatchRequest, opts ...grpc.CallOption) (*SignTxBatchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignTxBatchReply)
	err := c.cc.Invoke(ctx, Trade_SignTxBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradeServer is the server API for Trade service.
// All implementations must embed UnimplementedTradeServer
// for forward compatibility.
type TradeServer interface {
	GetTokenInfo(context.Context, *GetTokenInfoRequest) (*GetTokenInfoReply, error)
	GetTokenPrice(context.Context, *GetTokenPriceRequest) (*GetTokenPriceReply, error)
	GetTokenMarketCap(context.Context, *GetTokenMarketCapRequest) (*GetTokenMarketCapReply, error)
	GetTokenLiquidity(context.Context, *GetTokenLiquidityRequest) (*GetTokenLiquidityReply, error)
	GetTokenTradeInfo(context.Context, *GetTokenTradeInfoRequest) (*GetTokenTradeInfoReply, error)
	TradeTokenRawTx(context.Context, *TradeTokenRawTxRequest) (*TradeTokenRawTxReply, error)
	GetNativeBalance(context.Context, *GetNativeBalanceRequest) (*GetNativeBalanceReply, error)
	GetContractTokenBalance(context.Context, *GetContractTokenBalanceRequest) (*GetContractTokenBalanceReply, error)
	GetAddressNetworkType(context.Context, *GetAddressNetworkTypeRequest) (*GetAddressNetworkTypeReply, error)
	IsContract(context.Context, *IsContractRequest) (*IsContractReply, error)
	// 构建代币转账交易 代币地址为空时走主网币
	BuildTokenTransfer(context.Context, *BuildTokenTransferRequest) (*BuildTokenTransferReply, error)
	SecurityCheck(context.Context, *SecurityCheckRequest) (*SecurityCheckReply, error)
	GetNativeTokenPrice(context.Context, *GetNativeTokenPriceRequest) (*GetNativeTokenPriceReply, error)
	SendRawTx(context.Context, *SendRawTxRequest) (*SendRawTxReply, error)
	SendRawTxByPrivate(context.Context, *SendRawTxByPrivateRequest) (*SendRawTxByPrivateReply, error)
	// 交易状态
	GetTransactionStatus(context.Context, *GetTransactionStatusRequest) (*GetTransactionStatusReply, error)
	CreateAddress(context.Context, *CreateAddressRequest) (*CreateAddressReply, error)
	StoreSecret(context.Context, *StoreSecretRequest) (*StoreSecretReply, error)
	DecodeSecret(context.Context, *DecodeSecretRequest) (*DecodeSecretReply, error)
	StoreSecretBatch(context.Context, *StoreSecretBatchRequest) (*StoreSecretBatchReply, error)
	DecodeSecretBatch(context.Context, *DecodeSecretBatchRequest) (*DecodeSecretBatchReply, error)
	SignTx(context.Context, *SignTxRequest) (*SignTxReply, error)
	SignTxBatch(context.Context, *SignTxBatchRequest) (*SignTxBatchReply, error)
	mustEmbedUnimplementedTradeServer()
}

// UnimplementedTradeServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTradeServer struct{}

func (UnimplementedTradeServer) GetTokenInfo(context.Context, *GetTokenInfoRequest) (*GetTokenInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenInfo not implemented")
}
func (UnimplementedTradeServer) GetTokenPrice(context.Context, *GetTokenPriceRequest) (*GetTokenPriceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenPrice not implemented")
}
func (UnimplementedTradeServer) GetTokenMarketCap(context.Context, *GetTokenMarketCapRequest) (*GetTokenMarketCapReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenMarketCap not implemented")
}
func (UnimplementedTradeServer) GetTokenLiquidity(context.Context, *GetTokenLiquidityRequest) (*GetTokenLiquidityReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenLiquidity not implemented")
}
func (UnimplementedTradeServer) GetTokenTradeInfo(context.Context, *GetTokenTradeInfoRequest) (*GetTokenTradeInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenTradeInfo not implemented")
}
func (UnimplementedTradeServer) TradeTokenRawTx(context.Context, *TradeTokenRawTxRequest) (*TradeTokenRawTxReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TradeTokenRawTx not implemented")
}
func (UnimplementedTradeServer) GetNativeBalance(context.Context, *GetNativeBalanceRequest) (*GetNativeBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNativeBalance not implemented")
}
func (UnimplementedTradeServer) GetContractTokenBalance(context.Context, *GetContractTokenBalanceRequest) (*GetContractTokenBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContractTokenBalance not implemented")
}
func (UnimplementedTradeServer) GetAddressNetworkType(context.Context, *GetAddressNetworkTypeRequest) (*GetAddressNetworkTypeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddressNetworkType not implemented")
}
func (UnimplementedTradeServer) IsContract(context.Context, *IsContractRequest) (*IsContractReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsContract not implemented")
}
func (UnimplementedTradeServer) BuildTokenTransfer(context.Context, *BuildTokenTransferRequest) (*BuildTokenTransferReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildTokenTransfer not implemented")
}
func (UnimplementedTradeServer) SecurityCheck(context.Context, *SecurityCheckRequest) (*SecurityCheckReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityCheck not implemented")
}
func (UnimplementedTradeServer) GetNativeTokenPrice(context.Context, *GetNativeTokenPriceRequest) (*GetNativeTokenPriceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNativeTokenPrice not implemented")
}
func (UnimplementedTradeServer) SendRawTx(context.Context, *SendRawTxRequest) (*SendRawTxReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendRawTx not implemented")
}
func (UnimplementedTradeServer) SendRawTxByPrivate(context.Context, *SendRawTxByPrivateRequest) (*SendRawTxByPrivateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendRawTxByPrivate not implemented")
}
func (UnimplementedTradeServer) GetTransactionStatus(context.Context, *GetTransactionStatusRequest) (*GetTransactionStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionStatus not implemented")
}
func (UnimplementedTradeServer) CreateAddress(context.Context, *CreateAddressRequest) (*CreateAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAddress not implemented")
}
func (UnimplementedTradeServer) StoreSecret(context.Context, *StoreSecretRequest) (*StoreSecretReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreSecret not implemented")
}
func (UnimplementedTradeServer) DecodeSecret(context.Context, *DecodeSecretRequest) (*DecodeSecretReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeSecret not implemented")
}
func (UnimplementedTradeServer) StoreSecretBatch(context.Context, *StoreSecretBatchRequest) (*StoreSecretBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreSecretBatch not implemented")
}
func (UnimplementedTradeServer) DecodeSecretBatch(context.Context, *DecodeSecretBatchRequest) (*DecodeSecretBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeSecretBatch not implemented")
}
func (UnimplementedTradeServer) SignTx(context.Context, *SignTxRequest) (*SignTxReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignTx not implemented")
}
func (UnimplementedTradeServer) SignTxBatch(context.Context, *SignTxBatchRequest) (*SignTxBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignTxBatch not implemented")
}
func (UnimplementedTradeServer) mustEmbedUnimplementedTradeServer() {}
func (UnimplementedTradeServer) testEmbeddedByValue()               {}

// UnsafeTradeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradeServer will
// result in compilation errors.
type UnsafeTradeServer interface {
	mustEmbedUnimplementedTradeServer()
}

func RegisterTradeServer(s grpc.ServiceRegistrar, srv TradeServer) {
	// If the following call pancis, it indicates UnimplementedTradeServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Trade_ServiceDesc, srv)
}

func _Trade_GetTokenInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetTokenInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetTokenInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetTokenInfo(ctx, req.(*GetTokenInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_GetTokenPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetTokenPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetTokenPrice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetTokenPrice(ctx, req.(*GetTokenPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_GetTokenMarketCap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenMarketCapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetTokenMarketCap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetTokenMarketCap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetTokenMarketCap(ctx, req.(*GetTokenMarketCapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_GetTokenLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenLiquidityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetTokenLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetTokenLiquidity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetTokenLiquidity(ctx, req.(*GetTokenLiquidityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_GetTokenTradeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenTradeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetTokenTradeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetTokenTradeInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetTokenTradeInfo(ctx, req.(*GetTokenTradeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_TradeTokenRawTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeTokenRawTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).TradeTokenRawTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_TradeTokenRawTx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).TradeTokenRawTx(ctx, req.(*TradeTokenRawTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_GetNativeBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNativeBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetNativeBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetNativeBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetNativeBalance(ctx, req.(*GetNativeBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_GetContractTokenBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContractTokenBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetContractTokenBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetContractTokenBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetContractTokenBalance(ctx, req.(*GetContractTokenBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_GetAddressNetworkType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressNetworkTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetAddressNetworkType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetAddressNetworkType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetAddressNetworkType(ctx, req.(*GetAddressNetworkTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_IsContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).IsContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_IsContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).IsContract(ctx, req.(*IsContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_BuildTokenTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildTokenTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).BuildTokenTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_BuildTokenTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).BuildTokenTransfer(ctx, req.(*BuildTokenTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_SecurityCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).SecurityCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_SecurityCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).SecurityCheck(ctx, req.(*SecurityCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_GetNativeTokenPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNativeTokenPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetNativeTokenPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetNativeTokenPrice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetNativeTokenPrice(ctx, req.(*GetNativeTokenPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_SendRawTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRawTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).SendRawTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_SendRawTx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).SendRawTx(ctx, req.(*SendRawTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_SendRawTxByPrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRawTxByPrivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).SendRawTxByPrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_SendRawTxByPrivate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).SendRawTxByPrivate(ctx, req.(*SendRawTxByPrivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_GetTransactionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetTransactionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetTransactionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetTransactionStatus(ctx, req.(*GetTransactionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_CreateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).CreateAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_CreateAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).CreateAddress(ctx, req.(*CreateAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_StoreSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).StoreSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_StoreSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).StoreSecret(ctx, req.(*StoreSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_DecodeSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).DecodeSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_DecodeSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).DecodeSecret(ctx, req.(*DecodeSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_StoreSecretBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreSecretBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).StoreSecretBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_StoreSecretBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).StoreSecretBatch(ctx, req.(*StoreSecretBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_DecodeSecretBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeSecretBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).DecodeSecretBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_DecodeSecretBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).DecodeSecretBatch(ctx, req.(*DecodeSecretBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_SignTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).SignTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_SignTx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).SignTx(ctx, req.(*SignTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_SignTxBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignTxBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).SignTxBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_SignTxBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).SignTxBatch(ctx, req.(*SignTxBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Trade_ServiceDesc is the grpc.ServiceDesc for Trade service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Trade_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.trade.v1.Trade",
	HandlerType: (*TradeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTokenInfo",
			Handler:    _Trade_GetTokenInfo_Handler,
		},
		{
			MethodName: "GetTokenPrice",
			Handler:    _Trade_GetTokenPrice_Handler,
		},
		{
			MethodName: "GetTokenMarketCap",
			Handler:    _Trade_GetTokenMarketCap_Handler,
		},
		{
			MethodName: "GetTokenLiquidity",
			Handler:    _Trade_GetTokenLiquidity_Handler,
		},
		{
			MethodName: "GetTokenTradeInfo",
			Handler:    _Trade_GetTokenTradeInfo_Handler,
		},
		{
			MethodName: "TradeTokenRawTx",
			Handler:    _Trade_TradeTokenRawTx_Handler,
		},
		{
			MethodName: "GetNativeBalance",
			Handler:    _Trade_GetNativeBalance_Handler,
		},
		{
			MethodName: "GetContractTokenBalance",
			Handler:    _Trade_GetContractTokenBalance_Handler,
		},
		{
			MethodName: "GetAddressNetworkType",
			Handler:    _Trade_GetAddressNetworkType_Handler,
		},
		{
			MethodName: "IsContract",
			Handler:    _Trade_IsContract_Handler,
		},
		{
			MethodName: "BuildTokenTransfer",
			Handler:    _Trade_BuildTokenTransfer_Handler,
		},
		{
			MethodName: "SecurityCheck",
			Handler:    _Trade_SecurityCheck_Handler,
		},
		{
			MethodName: "GetNativeTokenPrice",
			Handler:    _Trade_GetNativeTokenPrice_Handler,
		},
		{
			MethodName: "SendRawTx",
			Handler:    _Trade_SendRawTx_Handler,
		},
		{
			MethodName: "SendRawTxByPrivate",
			Handler:    _Trade_SendRawTxByPrivate_Handler,
		},
		{
			MethodName: "GetTransactionStatus",
			Handler:    _Trade_GetTransactionStatus_Handler,
		},
		{
			MethodName: "CreateAddress",
			Handler:    _Trade_CreateAddress_Handler,
		},
		{
			MethodName: "StoreSecret",
			Handler:    _Trade_StoreSecret_Handler,
		},
		{
			MethodName: "DecodeSecret",
			Handler:    _Trade_DecodeSecret_Handler,
		},
		{
			MethodName: "StoreSecretBatch",
			Handler:    _Trade_StoreSecretBatch_Handler,
		},
		{
			MethodName: "DecodeSecretBatch",
			Handler:    _Trade_DecodeSecretBatch_Handler,
		},
		{
			MethodName: "SignTx",
			Handler:    _Trade_SignTx_Handler,
		},
		{
			MethodName: "SignTxBatch",
			Handler:    _Trade_SignTxBatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trade/v1/trade.proto",
}
